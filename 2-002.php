<?php
/* 
PHP は部分型の関係を満たしつつ(behavioral subtyping)、
名前ベースで一致を調べる型システム(nominal type system) 
を採用しています。 部分型の関係はコンパイル時に
チェックされますが、 型の検証は実行時に
動的に行われます。
PHP の型システムは、様々な基本型(atomic type)を
サポートしており、 それらを組み合わせて
より複雑な型を作ることができます。 
そうした複雑な型の一部については、 
型宣言 時に記述できます。

基本型の一部は言語に強く統合されている組み込み型であり、 
ユーザー定義の型として再現できません。
基本型の一覧は以下になります:
・組み込みの型
    ・ヌル(null)
    ・スカラー型:
        ・論理値(bool)
        ・整数(int)
        ・浮動小数点数(float)
        ・文字列(string)
    ・配列(array)
    ・オブジェクト(object)
    ・リソース(resource)
    ・never
    ・void
    ・クラス内での関係を示す相対型: self, parent, static

・Value型
    ・false
    ・true
・ユーザー定義型 (一般的に、クラス型とも呼びます)
    ・インターフェイス
    ・クラス
    ・列挙型(Enum)
・callable

複数の基本型を組み合わせて、
複合型を作ることができます。
 PHP では、次のやり方で型を組み合わせることができます:

・(インターフェイスやクラスの)交差型
    交差型 は、宣言した複数のクラス型を
    (単一ではなく) すべて満たす値を受け入れる
    ことができます。 交差型を構成する個別の型は、
    & 記号で結合します。よって、型 T, U, V の
    交差型は T&U&V と書きます
・union 型
    union 型は、ひとつではなく、 複数の異なる型
    を値として受け入れることができます。 
    union 型を構成する個別の型は、| 記号で
    結合します。よって、型 T, U, V の union 型は
     T|U|V と書きます。 型のひとつが交差型
     の場合、DNF で記すために 括弧で囲む
     必要があります。 つまり、T|(X&Y) と
     書く必要があります。
*/
?>

<?php
/* 
PHP の変数はドル記号の後に変数名が続く形式で表されます。 
変数名は大文字小文字を区別します。
変数名は、文字 (A-Z, a-z, 128から255 までのバイト) 
で始まり、 任意の数の文字、 数字、アンダースコア
が続きます。正規表現を使うと、
これは次の ように表現することができます。
 ^[a-zA-Z_\x80-\xff][a-zA-Z0-9_\x80-\xff]*$
*/
?>

<?php
$var = 'Bob';
$Var = 'Joe';
echo "$var, $Var";      // outputs "Bob, Joe"

//$4site = 'not yet';     // invalid; starts with a number
$_4site = 'not yet';    // valid; starts with an underscore
$täyte = 'mansikka';    // valid; 'ä' is (Extended) ASCII 228.
?>

<?php
${'invalid-name'} = 'bar';
$name = 'invalid-name';
echo ${'invalid-name'}, " ", $$name, "\n";
/* 
デフォルトでは、変数に代入されるのは常にその値です。
これは、つまり、ある変数にある式を代入する際、
元の式の 値全体がコピーされる側の変数にコピー
されるということです。 これは、例えば、
ある変数の値を他の変数に代入した後で、 
これらの変数の1つを変更しても他の変数には
影響を与えないという ことを意味します。
この種の代入に関するより詳細な情報については、 
式 を参照ください。
*/
?>

<?php
/* 
PHP には、変数に値の代入を行う別の方法も存在します。
それは、 参照による代入 です。 この場合、新規の
変数は元の変数を参照するだけです。 
(言いかえると、元の変数の"エイリアスを作る"
または元の変数を"指す") 
新規の変数への代入は、元の変数に影響し、
その逆も同様となります。
*/
?>

<?php
$foo = 'Bob';              // 値'Bob'を$fooに代入する。
$bar = &$foo;              // $fooを$barにより参照
echo $foo, "\n";
$bar = "My name is $bar";  // $barを変更...
echo $bar, "\n";
echo $foo, "\n";           // $fooも変更される。
?>

<?php
//注意すべき重要な点として、変数のみが
//参照により代入できる ということがあります。
$foo = 25;
$bar = &$foo;      // これは有効な代入です。
//$bar = &(24 * 7);  // 無効です。名前のない式を参照しています。

function test() {
   return 25;
}

//$bar = &test();    // 無効。なぜなら、リファレンスで値を返していないからです。
?>

<?php
/* 
PHP は、未定義の変数からの配列の 
autovivification (新しい配列の自動生成) を
許可しています。 未定義の変数に要素を追加する操作
は、 新しい配列を生成し、警告は発生しません。
*/
$unset_array[] = 'value'; // 警告は発生しません
?>